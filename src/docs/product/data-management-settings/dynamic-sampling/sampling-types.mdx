---
title: Dynamic Sampling Types
sidebar_order: 30
description: "Learn more about the types of sampling available for your project and their benefits."
---

With dynamic sampling, you can sample by individual events or by entire traces. If you sample by traces, you
can sample by specific cases: release, environment, and user. Learn how to
[setup dynamic-sampling rules](/product/data-management-settings/dynamic-sampling/configuration/).

<!-- This will be temporarily commented out until we enable the error rules again
Dynamic sampling operates on both error events and transaction events.
-->

Dynamic sampling operates on transaction events.

<!-- This will be temporarily commented out until we enable the error rules again

## Errors

Error sampling decisions are made based on the event data.

A sampling rule is selected from the available sampling rules by going through the list of dynamic sampling rules for
errors and picking up the first rule that matches the event data. Rule matching is described in more detail in
[dynamic sampling configuration](/product/data-management-settings/dynamic-sampling/configuration/).

-->

## Transactions

Transactions can be considered either as independent events or in the context of all other transactions belonging to a
trace, see [tracing](/product/sentry-basics/tracing/) for an in depth explanation about tracing.

Sentry offers the possibility to sample transactions either independently or as part of a trace; there are different
benefits for each case.

Sampling transactions using transaction traces is advantageous when trying to understand transactions in the context of
the global system. In this case we are not interested in seeing a particular transaction, but the whole group of
transactions in a trace so sampling should occur at the trace level.

When sampling transaction traces, the sampling rules are based on the transaction context, this means that the sampling
decisions are based on the information extracted from the system that initiated the transaction.

While sampling transaction traces gives a very good view of how transactions flow through the system, sometimes we are
interested in analysing transactions from a particular service that happens not to be the initiator of transaction
(e.g. a backend server). If we are interested in creating rules based on attributes specific to our service, for
example we have a suspicion that a particular release might have some performance problems, we can sample based on
transaction event.

Individual transaction rules are based on the transaction attributes and not on the trace context attributes and
therefore can target individual services that are not initiating traces.
